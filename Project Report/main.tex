% !TeX program = xelatex
\documentclass[12pt, a4paper]{article}

% --- Essential Packages ---
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{float}
\usepackage{lastpage}

% --- For Fonts and Language Support (Essential for modern TeX) ---
\usepackage{fontspec}
\setmainfont{Times New Roman}
\usepackage[math-style=ISO]{unicode-math}

% --- For Colors, Tables, and Advanced Text Formatting ---
\usepackage[table, xcdraw]{xcolor}
\usepackage[dvipsnames]{xcolor}
\usepackage{multirow}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}

% --- For Code Listings, Algorithms, and Diagrams ---
\usepackage{minted}
\usepackage[linesnumbered, ruled, vlined]{algorithm2e}
\usepackage{subcaption}

% --- For Hyperlinks and Document Structure ---
\usepackage{fancyhdr}
\usepackage[colorlinks, urlbordercolor=blue]{hyperref} 

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=black,
    urlcolor=black,
}

\pagestyle{fancy}
\fancyhf{} % clear all header and footer fields

% Define header
\fancyhead[L]{SWE 4304: Software Project Lab I}
\fancyhead[C]{}
\fancyhead[R]{Project Report (Group 7)}

% Define footer
\renewcommand{\footrulewidth}{0.4pt}
\fancyfoot[L]{}
\fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}
\fancyfoot[R]{}


\begin{document}

\begin{titlepage}
    \begin{figure}[!h]
    \centering
    \includegraphics[width=.2\textwidth]{images/iut_logo.png}
\end{figure}
\begin{center}

\noindent\rule{\textwidth}{1.5pt}

\Huge{\textbf{Islamic University of Technology}}\\
\large{\textbf{Department of Computer Science and Engineering (CSE)}}\\
\large{{B.Sc. in Software Engineering}}\\
\vspace{0.2cm}
\Large{\textbf{SWE 4304:} Software Project Lab I}\\
\Large{{Winter}, 2024-2025}\\
\noindent\rule{\textwidth}{0.5pt}

\vspace{1cm}
\Large{\textbf{Project Report}} \\
\Large{{The ‘Drim’ Programming Language}} \\
\vspace{1cm}

\vspace{0.5cm}
\large{\textbf{Group 7}} \\
\large{Md. Muntahi Hasan Akhiar, 230042118}\\
\large{S.M. Tahsinuzzaman Emon, 230042104}\\
\large{Tamim Mahrush Naser, 230042133}\\

\vspace{1.5cm}
\large{\textbf{Supervisor}} \\
\large{Farzana Tabassum,\\ Lecturer, CSE}\\

\vspace{1.5cm}
\large{{Date: December 13, 2025}} \\

\end{center}
\end{titlepage}

\newpage

% --- Table of Contents ---
\tableofcontents

\newpage

\begin{center}
    \Large{\textbf{The ‘Drim’ Programming Language}}
\end{center}

\section{Project Overview}
\textbf{``Drim''} is a custom-built, interpreted programming language designed to run as a lightweight, headless command-line interface (CLI) application. Unlike standard compilers that translate source code into machine code, Drim functions as a \textbf{Tree-Walk Interpreter} that reads custom \texttt{.drim} source files, constructs an internal Abstract Syntax Tree (AST), and executes logic in real-time.

The project is built entirely from scratch using \textbf{C++ (Standard 17)}, adhering to strict constraints that prohibit the use of external parsing libraries (like Lex or Yacc) or heavy standard library functions (like \texttt{std::stoi} or Regex). This ensures that every component of the language pipeline—from lexical analysis to memory management—is engineered manually by the team.

The primary goal of the project is to create a functional programming environment that supports dynamic typing, mathematical operations, and custom control flow structures (such as \texttt{drimming} for loops and \texttt{wake} for output), providing a simplified yet robust platform for logic execution.

\newpage
\section{Motivation Behind the Project}
At its core, Drim is about two things: preserving classroom culture and mastering complex engineering concepts.
\subsection*{Cultural Significance}
The name \textbf{“Drim”} originated as an inside joke and a shared meme within the student batch from the very first day of our university life. Rather than letting this remain as a joke that might die over time, we decided to create something that will help us immortalize the memory of our classroom culture. Which is the reason we are personalizing this project with syntax and keywords like “DrimIn”, “Drimming” to reflect our motivation. This relevance should increase our team’s engagement and passion for the project, since there is a class full of people looking forward to seeing our project, materialization of our joke, unfold.
\subsection*{Engineering Challenges}
From a technical perspective, this project serves as a rigorous exercise in system-level programming. We chose to build an interpreter from scratch to accomplish three specific learning outcomes:
\begin{itemize}
    \item \textbf{Deep Understanding of Language Design:} By manually implementing lexical analysis, parsing, and interpretation, we gain firsthand experience with the inner workings of programming languages.
    \item \textbf{Memory Management Proficiency:} The project requires careful handling of dynamic memory allocation and deallocation, fostering a strong grasp of pointers and resource management in C++.
    \item \textbf{Problem-Solving Skills:} Restricting the use of third-party libraries and STL functions challenges us to engineer custom, innovative solutions from scratch and strengthens our problem solving skill.
    \item \textbf{Collaboration and Project Management:} Working as a group on a complex software project enhances teamwork, version control practices, and project planning skills.
\end{itemize}



\newpage

\section{Key Feature}
The goal with Drim is to create something that balances simplicity with power. We are taking inspiration from standard C++ and Python architecture but deciding to go our own way with the implementation. By using custom keywords and limiting the feature set, we are avoiding unnecessary bloat. This will allow Drim to run logic through our custom Tree-Walk Interpreter implementation while keeping the code clean, readable, and uniquely ours.\\ 
\begin{itemize}
    \item \textbf{Input/Output:} \textbf{Drim} accepts user input via the \textbf{drimIn()} command and display formatted output using the \textbf{wakeOut()} command
    \item \textbf{Automatic Variable Assignment:} In the event of a user trying to assign a value to an undeclared variable, \textbf{Drim} can declare the variable on its own with the intended data type and assign the value given by the user to the newly created variable.
    \item \textbf{Dynamic Type Casting:} Variables in \textbf{Drim} can hold either String or Integer or Boolean values, with implicit type casting handled by the interpreter. This feature simplifies variable management and enhances user experience.
    \item \textbf{Mathematical Operations:} \textbf{Drim} can correctly evaluate arithmetic expressions (+, -, *, /, \%) respecting standard operator precedence.
    \item \textbf{Conversion Calculation:} Instead of requiring users to manually declare functions for common unit conversions, \textbf{Drim} provides pre-defined functions for converting between standard types (such as \textbf{degrees to radians}, \textbf{Fahrenheit to Celsius}, and \textbf{kilometers to feet}). This allows users to perform conversions efficiently without needing to look up rates externally.
    \item \textbf{Physics \& Math Formulas:} \textbf{Drim} will be able to execute complex calculations, such as computing force or momentum, using pre-built functions rather than writing raw equations from scratch.
    \item \textbf{Control Flow:} The language supports conditional statements (\texttt{if-else}) and looping constructs (\texttt{drimming} loops) to let users control the flow of execution based on dynamic conditions.
    \item \textbf{Custom Syntax \& Semantics:} The language utilizes a unique set of keywords tailored to the project's theme. Notable examples include the \textbf{drimming}
                                                command for iterative loops and the \texttt{wake()} function for standard output. 
                                                This custom syntax demonstrates the flexibility of the Lexer design.
    \item \textbf{String Interpolation:} Unlike many basic custom languages that only supports simple stgring printing,
                                         Drim supports advanced string intercpolation. Users can embed variables directly within string literals (e.g., \texttt{wake("Value: {x})}),
                                         allowing for dyunamic and readable output generation. 
    \item \textbf{Dynamic Typing:} Variables in \textbf{Drim} can hold either String or Integer values, with implicit type casting handled by the interpreter. 
                                    This feature simplifies variable management and enhances user experience.
    \item \textbf{Headless Execution:} Designed specifically as a backend tool, Drim runs as a lightweight, headless Command Line Interface (CLI) application. It executes scripts fetched from a .drim file directly in the terminal without the overhead of a Graphical User Interface (GUI).
    \item \textbf{Zero-Dependency Architecture:} A defining feature of Drim is its independence. It does not rely on third-party parsing libraries or heavy standard library tools (such as Regex). Every component, from tokenization to the Abstract Syntax Tree (AST) construction, will be engineered manually using C++ 17.
\end{itemize}

\newpage
\section{Flow Chart/Class Diagram}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.6\linewidth]{images/flowchart.png}
    \caption{System Architecture Flow: From Source Code to Execution}
    \label{fig:flowchart}
\end{figure}
\newpage
\subsection*{Process Description}
\begin{enumerate}
    \item \textbf{Source Code (.drim):} The raw text file provided by the user containing the custom script.
    \item \textbf{Lexer (Tokenizer):} Scans the source code character-by-character to generate a sequence of \textbf{Tokens} (Keywords, Identifiers, Literals).
    \item \textbf{Parser:} Analyzes the token sequence against the language grammar rules. It constructs an \textbf{Abstract Syntax Tree (AST)} composed of Statement and Expression nodes.
    \item \textbf{Interpreter:} Traverses the AST recursively. It executes Statements (actions) and evaluates Expressions (values), interacting with the \textbf{Environment} (Memory) to store and retrieve variable states.
    \item \textbf{Output:} The result of the execution is printed to the standard output (Console).
\end{enumerate}



\newpage
\section{Tools and Technologies}
In designing Drim, our tooling choices were driven by a philosophy of complete control without relying on "black box" abstractions. Below are the technologies selected and the alternatives we weighed them against.

\begin{itemize}
    \item \textbf{Programming Language: C++ (Standard 17)} \\ 
    \\
    \textbf{Choice:} We selected C++ 17 to leverage modern features while retaining the manual memory control required for a manually built interpreter. \\
    \textbf{Alternatives:} We considered \textbf{C++ 23} for its new library functions but opted out since usage of library functions are restricted.\\ 
    Managed languages like \textbf{Java} or \textbf{C\#} were rejected to avoid the unpredictable performance overhead of Garbage Collection and the amount of library functions we need to use for basic tasks like input and output (scanner.nextInt(), scanner.nextLine()).\\
    We did not choose \textbf{Python} or \textbf{JavaScript} due to their interpreted nature, which would complicate low-level memory management and pointer manipulation.

    \item \textbf{Build System: CMake} \\
    \\
    \textbf{Choice:} Utilized to abstract the build process, ensuring the project allows for cross-platform compatibility without rewriting makefiles. \\
    \textbf{Alternatives:} \textbf{GNU Make} was considered but seemed unmanageable as the project directory structure will grow. \\
    Manual compilation scripts were rejected due to the difficulty of tracking header dependencies.

    \item \textbf{Version Control: Git \& GitHub} \\
    \\
    \textbf{Choice:} Used for distributed and shared source code management, allowing us to implement experimental features in isolation using branches. And all team members are familiar with GitHub's interface. \\
    \textbf{Alternatives:} Centralized systems like \textbf{SVN} were dismissed in favor of Git's standard branching and merging capabilities, which facilitate better team collaboration.

    \item \textbf{IDE: CLion / Visual Studio Code} \\
    \\
    \textbf{Choice:} \textbf{CLion} is our primary environment for its in depth deep memory inspection tools (vital for debugging segmentation faults), while \textbf{Visual Studio Code} is used as a lightweight editor for quick iteration.

    \item \textbf{Diagramming: Mermaid.js / Gamma} \\
    \\
    \textbf{Choice:} Used for creating Gantt charts and architecture diagrams. \\
    \textbf{Alternatives:} We avoided drag-and-drop tools like \textbf{Visio} or \textbf{Lucidchart} in favor of \textbf{Mermaid.js}, which allows us to treat "diagrams as code" and version control our documentation alongside the source.
\end{itemize}

\newpage
\section{Proposed Timeline}

\begin{figure}[!h]
    \centering
    \includegraphics[width=1\linewidth]{images/timeline-2.png}
    \caption{Timeline Diagram (Gantt Chart)}
    \label{fig:timeline}
    
\end{figure}

\newpage
\section{Suggestions Received}
The suggestions that we received are -

\begin{itemize}
    \item \textbf{Suggestion 1:}
    Details about suggestion 1 and how it will be addressed.
    \item \textbf{Suggestion 2:}
    Details about suggestion 2 and how it will be addressed.

\end{itemize}

\newpage
\section{Links}

\begin{enumerate}

    \item \href{(link)}{Presentation Slide Link}
    \item \href{https://github.com/hasanakhiar/drim-lang}{GitHub Repository Link}
\end{enumerate}

\newpage
\end{document}